
[Prev](stage10.md) | [Home](../intro.md) | Next

# Stage 11

In [**Stage 10**](stage10.md), `lib_xcore_math`'s digital filter API was used to
implement the FIR filter. **Stage 11** also makes use of the FIR filter API, but
indirectly.

In addition to the digital filter API, `lib_xcore_math` also provides a set of
Python scripts for converting existing digital filters (with floating-point
coefficients) into a form compatible with xcore, and even generates code which
can be directly compiled into the application.

Specifically, for this example the script [`gen_fir_filter_s32.py`](TODO) was
used, with [`coef.csv`](TODO) as input, to generate [`userFilter.c`](TODO) and
[`userFilter.h`](TODO). The script generates a named filter, where the function
names in the generated API are based on the filter name. In this example, the
filter name (specified when calling the script) is "userFilter".

The filters generated with these scripts allocate and manage their own memory,
resulting in very simple API calls.

## Introduction

```
TODO
```

## Background

```
TODO
```

## Generating Filters

The `userFilter.c` and `userFilter.h` used in this stage were provided with this
tutorial as a convenience. You can generate these files yourself using `gen_fir_filter_s32.py`. This will require Python 3 with numpy.

```sh
$ python gen_fir_filter_s32.py -h
usage: gen_fir_filter_s32.py [-h] [--taps TAPS] [--out-dir OUT_DIR] [--input-headroom INPUT_HEADROOM] [--output-headroom OUTPUT_HEADROOM]
                             filter_name filter_coefficients
```

The script requires 2 arguments: the name of the filter, `filter_name`, and a
path to a `.csv` file containing the filter coefficients. The filter
coefficients must be floating-point values with the coefficients separated by
commas and/or whitespace. The coefficient order is `b[0]`, `b[1]`, `b[2]`, etc.

To generate the filter, starting from your workspace root:

```sh
cd xmath_walkthrough/src/stage11
python ../../lib_xcore_math/lib_xcore_math/script/gen_fir_filter_s32.py --taps 1024 userFilter coef.csv
```

The output should be similar to the following:

```sh
workspace\xmath_walkthrough\src\stage11$ python ..\..\lib_xcore_math\lib_xcore_math\script\gen_fir_filter_s32.py --taps 1024 userFilter coef.csv
Filter tap count: 1024
Files to be written:
  .\userFilter.h
  .\userFilter.c
```

The `--taps` option is used to ensure that the converted filter has the expected
number of filter taps.


## Implementation

The `rx_frame()` and `tx_frame()` in **Stage 11** are the same as those in
**Stage 10**. **Stage 11** also includes two additional files, `userFilter.h`
and `userFilter.c` which were generated by the filter conversion script. These
files are intended to be opaque, but are simple, so feel free to take a look.

### **Stage 10** `filter_task()` Implementation

From [`stage11.c`](TODO):
```C
/**
 * This is the thread entry point for the hardware thread which will actually 
 * be applying the FIR filter.
 * 
 * `c_audio` is the channel over which PCM audio data is exchanged with tile[0].
 */
void filter_task(
    chanend_t c_audio)
{
  // This buffer is where input/output samples will be placed.
  int32_t sample_buffer[FRAME_SIZE] = {0};

  // Initialize userFilter. userFilter allocates and manages its own buffers and
  // filter object, so no buffer needs to be supplied.
  userFilter_init();
  
  // If userFilter_exp_diff is not 0, the results will be wrong.
  assert(userFilter_exp_diff == 0);

  // Loop forever
  while(1) {

    // Read in a new frame
    rx_frame(&sample_buffer[0], 
             c_audio);
    
    // Compute FRAME_SIZE output samples.
    for(int s = 0; s < FRAME_SIZE; s++){
      timer_start(TIMING_SAMPLE);
      // userFilter() is the generated function to add a new input sample and get
      // back the filtered result.
      sample_buffer[s] = userFilter(sample_buffer[s]);
      timer_stop(TIMING_SAMPLE);
    }

    // Send out the processed frame
    tx_frame(c_audio, 
             &sample_buffer[0]);
  }
}
```

We can see that this is just a simpler version of `filter_task()` from **Stage
10**. Here, instead of manually declaring state for and explicitly initializing
a `filter_fir_s32_t` object, we just call the generated function
`userFilter_init()` (from `userFilter.h`) to initialize everything for us. Then,
instead of calling `filter_fir_s32()` to get a new output sample, we just call
`userFilter()` with our new input sample.


## Results

```
TODO
```
